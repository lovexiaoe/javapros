reactive programming 需要java 9才能运行，reactive Stream定义了一种无阻塞背压的异步流处理机制，有以下3个要素
1，一个信息的发布者，
2，一个或者多个信息的订阅者
3，在发布者和订阅者之间的订阅动作。

reactive stream 规范规定这些类之间如何互相交互，需要遵从下面的规则：

1，发布者需要添加他要通知的订阅者
2，当订阅者被添加到发布者后，订阅者会收到一个通知。
3，订阅者需要以异步方式向发布者请求一个或者多个元素，也就是说，订阅者请求元素并继续执行。
4，当发布者有元素要发布时，它会想所有请求这个元素的订阅者发送这个元素。

以上所有通讯都是异步的，所以我们可以充分利用多核处理器的优势。

这里说明一下背压的概念，背压是流控（flow control）中的一个方案，可以作为了解。

就像小学做的那道数学题：一个水池，有一个进水管和一个出水管。如果进水管水流更大，过一段时间水池就会满（溢出）。
这就是没有Flow Control导致的结果

而解决Flow Control有几种思路呢？
    （1）Backpressure，就是消费者需要多少，生产者就生产多少。这有点类似于TCP里的流量控制，接收方根据自己的接收窗口的情况来控制接收速率，
    并通过反向的ACK包来控制发送方的发送速率。这种方案只对于cold Observable有效。cold Observable是那些允许降低速率的发送源，比如两台机器传一个文件，
    速率可大可小，即使降低到每秒几个字节，只要时间足够长，还是能够完成的。相反的例子就是音视频直播，速率低于某个值整个功能就没法用了（这种类似于hot Observable）。
    （2）节流（Throttling），说白了就是丢弃。消费不过来，就处理其中一部分，剩下的丢弃。至于处理哪些和丢弃哪些，就有不同的策略，
    还是举音视频直播的例子，在下游处理不过来的时候，就需要丢弃数据包。
    （3）打包（buffer和window）。buffer和window基本一样，只是输出格式不太一样。它们是把上游多个小包裹打成大包裹，分发到下游。这样下游需要处理的包裹的个数就减少了。
    （4）是一种特殊情况，阻塞住整个调用链（Callstack blocking）。之所以说这是一种特殊情况，是因为这种方式只适用于整个调用链都在一个线程上同步执行，
    这要求中间的各个operator都不能启动新的线程。
